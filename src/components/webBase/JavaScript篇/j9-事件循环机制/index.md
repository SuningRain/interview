一、首先要明白浏览器进程是多线程的包括一下几种

1. GUI 渲染进程
   负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
   当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
   GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

2. JS 引擎进程
   也称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）
   JS 引擎线程负责解析 Javascript 脚本，运行代码。
   JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序
   同样注意，GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

3. 事件触发进程
   归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）
   当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程, 如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
   当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
   注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）

4. 定时触发器进程
   传说中的 setInterval 与 setTimeout 所在线程
   浏览器定时计数器并不是由 JavaScript 引擎计数的, （因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
   因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
   注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

5. 异步 http 请求进程
   在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
   将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

二、WebWorker
上面说了，JS 是单线程的，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。

Web Worker，是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

Web Worker 有几个特点：

- 同源限制：分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。
- DOM 限制：不能操作 DOM
- 通信联系：Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。
- 脚本限制：不能执行 alert()方法和 confirm()方法
- 文件限制：无法读取本地文件

三、浏览器渲染流程

- 用户输入 url ，DNS 解析成请求 IP 地址
- 浏览器与服务器建立连接（tcp 协议、三次握手），服务端处理返回 html 代码块
- 浏览器接受处理，解析 html 成 dom 树、解析 css 成 cssobj
- dom 树、cssobj 结合成 render 树
- JS 根据 render 树进行计算、布局、重绘
- GPU 合成，输出到屏幕

四、事件循环机制

- 执行整体代码，如果是同步任务，就直接在主线程上执行，形成一个执行栈
- 当遇到异步任务的时候如网络请求等，就交给其他线程执行, 当异步任务执行完了，就往事件队列里面塞一个回调函数
- 旦执行栈中的所有同步任务执行完毕（即执行栈空），就会读取事件队列，取一个任务塞到执行栈中，开始执行
- 一直重复步骤

宏任务和微任务

1. 微任务的优先级高于宏任务
2. w3c 最新的解释已经不再使用宏任务队列的这个说法了，而是包括了很多个队列，比如存放定时器的队列是延时队列，存放用户交互操作的是交互队列
3. 当 setTimeout 嵌套超过 5 层的时候，将最小间隔设置为 4ms，而具体浏览器厂商实现的方式可能不同，要看源码，我记得 chrome 的做法是如果嵌套不超过 5 层，那么实际的延迟时间是 max(传入计时器的延迟时间，1ms)，也就是说小于 1ms 的值，默认使用 1ms

五、Node 的事件循环
node 的事件循环比浏览器复杂很多。由 6 个宏任务队列+6 个微任务队列组成
优先级
Timers
I/O callbacks
Idle, prepare
Poll
Check
Close callcack

其执行规律是：在一个宏任务队列全部执行完毕后，去清空一次微任务队列，然后到下一个等级的宏任务队列，以此往复。一个宏任务队列搭配一个微任务队列。

六个等级的宏任务全部执行完成，才是一轮循环。

其中需要关注的是：Timers、Poll、Check 阶段，因为我们所写的代码大多属于这三个阶段。

Timers：定时器 setTimeout/setInterval；
Poll ：获取新的 I/O 事件, 例如操作读取文件等；
Check：setImmediate 回调函数在这里执行；

除此之外，node 端微任务也有优先级先后：

process.nextTick;
promise.then 等;

清空微任务队列时，会先执行 process.nextTick，然后才是微任务队列中的其他。

六、node11.x 前后版本差异

node11.x 之前，其事件循环的规则就如上文所述：先取出完一整个宏任务队列中全部任务，然后执行一个微任务队列。
但在 11.x 之后，node 端的事件循环变得和浏览器类似：先执行一个宏任务，然后是一个微任务队列。但依然保留了宏任务队列和微任务队列的优先级。
